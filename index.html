<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ThreeAmmo</title>

    <style>
        body {
            margin: 0;
            touch-action: none;
            background-image: -webkit-gradient(linear, 0 0, 100% 100%, color-stop(0, #877fa8), color-stop(100%, #f9ae91));
            background-image: -webkit-linear-gradient(135deg, #877fa8, #f9ae91);
            background-image: -moz-linear-gradient(45deg, #877fa8, #f9ae91);
            background-image: -ms-linear-gradient(45deg, #877fa8 0, #f9ae91 100%);
            background-image: -o-linear-gradient(45deg, #877fa8, #f9ae91);
            background-image: linear-gradient(135deg, #877fa8, #f9ae91);
        }

        canvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
</head>

<body>

</body>
<script src="./src/lib/ammo.js"></script>

<script type="module">
    import * as THREE from './src/lib/three.module.js';
    // Three.js
    var scene = undefined;
    var camera = undefined;
    var renderer = undefined;
    var clock = undefined;

    var tmpTransformation = undefined;
    Ammo().then(AmmoStart);
    function AmmoStart() {
        tmpTransformation = new Ammo.btTransform();
        initPhysicsUniverse();
        initGraphicsUniverse();

        createCube(40, new THREE.Vector3(15, -30, 15), 0);

        createCube(4, new THREE.Vector3(0, 10, 0), 1, null);
        createCube(2, new THREE.Vector3(10, 30, 0), 1, null);
        createCube(4, new THREE.Vector3(10, 20, 10), 1, null);
        createCube(6, new THREE.Vector3(5, 40, 20), 1, null);
        createCube(8, new THREE.Vector3(25, 100, 5), 1, null);
        createCube(8, new THREE.Vector3(20, 60, 25), 1, null);
        createCube(4, new THREE.Vector3(20, 100, 25), 1, null);
        createCube(2, new THREE.Vector3(20, 200, 25), 1, null);
        render();
    }
    var physicsUniverse = undefined;
    // ------ Phisics World setup ------
    function initPhysicsUniverse() {
        var collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
        var dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
        var overlappingPairCache = new Ammo.btDbvtBroadphase();
        var solver = new Ammo.btSequentialImpulseConstraintSolver();

        physicsUniverse = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
        physicsUniverse.setGravity(new Ammo.btVector3(0, -75, 0));
    }
    // ------ Three.js setup ------
    function initGraphicsUniverse() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.set(-25, 20, -25);
        camera.lookAt(new THREE.Vector3(0, 6, 0));
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        clock = new THREE.Clock();

        //light
        var ambientLight = new THREE.AmbientLight(0xcccccc, 0.2);
        scene.add(ambientLight);
        var directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(-1, 0.9, 0.4);
        scene.add(directionalLight);
    }

    var rigidBody_List = new Array();
    function createCube(scale, position, mass, rot_quaternion) {
        let quaternion = undefined;

        if (rot_quaternion == null) {
            quaternion = { x: 0, y: 0, z: 0, w: 1 };
        }
        else {
            quaternion = rot_quaternion;
        }

        // ------ Graphics Universe - Three.JS ------
        let newcube = new THREE.Mesh(new THREE.BoxBufferGeometry(scale, scale, scale), new THREE.MeshPhongMaterial({ color: Math.random() * 0xffffff }));
        newcube.position.set(position.x, position.y, position.z);
        scene.add(newcube);

        // ------ Physics Universe - Ammo.js ------
        let transform = new Ammo.btTransform();
        transform.setIdentity();
        transform.setOrigin(new Ammo.btVector3(position.x, position.y, position.z));
        transform.setRotation(new Ammo.btQuaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w));
        let defaultMotionState = new Ammo.btDefaultMotionState(transform);

        let structColShape = new Ammo.btBoxShape(new Ammo.btVector3(scale * 0.5, scale * 0.5, scale * 0.5));
        structColShape.setMargin(0.05);

        let localInertia = new Ammo.btVector3(0, 0, 0);
        structColShape.calculateLocalInertia(mass, localInertia);

        let RBody_Info = new Ammo.btRigidBodyConstructionInfo(mass, defaultMotionState, structColShape, localInertia);
        let RBody = new Ammo.btRigidBody(RBody_Info);

        physicsUniverse.addRigidBody(RBody);
        newcube.userData.physicsBody = RBody;
        rigidBody_List.push(newcube);
    }

    function updatePhysicsUniverse(deltaTime) {
        physicsUniverse.stepSimulation(deltaTime, 10);

        for (let i = 0; i < rigidBody_List.length; i++) {
            let Graphics_Obj = rigidBody_List[i];
            let Physics_Obj = Graphics_Obj.userData.physicsBody;
            let tmpTransformation = new Ammo.btTransform();

            let motionState = Physics_Obj.getMotionState();
            if (motionState) {
                motionState.getWorldTransform(tmpTransformation);
                let new_pos = tmpTransformation.getOrigin();
                let new_qua = tmpTransformation.getRotation();
                Graphics_Obj.position.set(new_pos.x(), new_pos.y(), new_pos.z());
                Graphics_Obj.quaternion.set(new_qua.x(), new_qua.y(), new_qua.z(), new_qua.w());
            }
        }
    }


    function render() {
        let deltaTime = clock.getDelta();
        updatePhysicsUniverse(deltaTime);

        renderer.render(scene, camera);
        requestAnimationFrame(render);
    }
</script>

</html>